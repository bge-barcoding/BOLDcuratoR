From fd3314cc20b2c813ccc714d56ee4b972784458cb Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Wed, 18 Feb 2026 09:19:08 +0000
Subject: [PATCH] Improve error handling, case sensitivity, and resilience in
 search functions

1. bold.public.search: Propagate actual error messages instead of
   swallowing them with generic "No records found with given criteria".

2. parameter_validation: Use case-insensitive comparison so that
   "baetis rhodani" matches "Baetis rhodani" from the BOLD API.
   Report which specific terms failed instead of blank stop("").

3. counts_query: Warn about zero-count terms and filter them out
   instead of returning NULL for the entire query.

4. preprocess_query: Replace opaque "Re-check search queries" with a
   message listing which terms BOLD could not resolve.

5. Trim whitespace from all list inputs to prevent silent mismatches.

6. Improved "Input data must be a list" error to suggest list()/as.list().

https://claude.ai/code/session_01QPYKx1YtbVdrWkVsrfi6oc
---
 R/external.bold.full.search.R             |  2 +-
 R/external.bold.public.search.R           | 19 ++++++++--
 R/helper.functions.4.bold.public.search.R | 45 ++++++++++++++++-------
 3 files changed, 48 insertions(+), 18 deletions(-)

diff --git a/R/external.bold.full.search.R b/R/external.bold.full.search.R
index bfc1357..a3962d5 100644
--- a/R/external.bold.full.search.R
+++ b/R/external.bold.full.search.R
@@ -176,7 +176,7 @@ bold.full.search <- function(taxonomy=NULL,
 
   if (any(!sapply(non_null_args, is.list))) {
 
-    stop("Input data must be a list.")
+    stop("Input data must be a list. Use list() or as.list() for each parameter.")
   }
 
   # The final list is then used to compile a JSON that is used by the API.
diff --git a/R/external.bold.public.search.R b/R/external.bold.public.search.R
index 8b8b240..deb4bca 100644
--- a/R/external.bold.public.search.R
+++ b/R/external.bold.public.search.R
@@ -84,9 +84,14 @@ bold.public.search <- function(taxonomy = NULL,
   #
   if (any(!sapply(non_null_args, is.list))) {
 
-    stop("Input data must be a list.")
+    stop("Input data must be a list. Use list() or as.list() for each parameter.")
   }
 
+  # Trim whitespace from all input values to avoid silent mismatches
+  non_null_args <- lapply(non_null_args, function(param) {
+    lapply(param, trimws)
+  })
+
   # The query input
 
   # trial_query_input = unlist(non_null_args)|>unname()
@@ -131,7 +136,11 @@ bold.public.search <- function(taxonomy = NULL,
 
     error = function(e) {
 
-      message("No records found with given criteria")
+      if (nchar(e$message) > 0) {
+        message(paste("No records found with given criteria:", e$message))
+      } else {
+        message("No records found with given criteria")
+      }
 
       return(NULL)
     })
@@ -171,7 +180,11 @@ bold.public.search <- function(taxonomy = NULL,
 
       error = function(e) {
 
-        message("No records found with given criteria")
+        if (nchar(e$message) > 0) {
+          message(paste("No records found with given criteria:", e$message))
+        } else {
+          message("No records found with given criteria")
+        }
 
         return(NULL)
 
diff --git a/R/helper.functions.4.bold.public.search.R b/R/helper.functions.4.bold.public.search.R
index 9ad712c..58cfdaa 100644
--- a/R/helper.functions.4.bold.public.search.R
+++ b/R/helper.functions.4.bold.public.search.R
@@ -96,14 +96,16 @@ preprocess_query<-function(parsed_query)
   json_preprocess_data_final=json_preprocess_data_final%>%
     dplyr::mutate(names=gsub("^na:na:",'',.$submitted))
 
-  tryCatch({
-    if (any(grepl("ids:", json_preprocess_data_final$matched))) {
-      stop("Re-check search queries")
-    }
-    # Code continues here if no error
-  }, error = function(e) {
-    stop(e)
-  })
+  # Check for unresolved terms (BOLD tags them with "ids:" prefix when it
+  # cannot match a term to any taxonomy/geography/BIN).  Report which terms
+  # failed so the user can fix typos or capitalization.
+  ids_mask <- grepl("ids:", json_preprocess_data_final$matched)
+  if (any(ids_mask)) {
+    bad_terms <- json_preprocess_data_final$names[ids_mask]
+    stop(paste0("BOLD could not resolve these search terms: ",
+                paste(bad_terms, collapse = ", "),
+                ". Check spelling and capitalization."))
+  }
 
   return(json_preprocess_data_final)
 
@@ -176,9 +178,18 @@ counts_query<-function (preprocessed_query)
   # For displaying number of specimen records available
 
 
-  # Check for 0 observations. This is put to check any misspellings or no data availability condition in the multi parameter queries which if not dealt with will return the entire dataset of the correctly spelled/available data query terms. Ex. Panthera leo + India vs Panthera leoss + India; the former will correctly query using 'and' logic while the latter due to a misspelling would retrieve all the data pertaining to India.
+  # Warn about terms with 0 observations (misspellings, no public data, etc.)
+  # and remove them so the remaining valid terms can still return results.
+
+  zero_mask <- result$counts_df[["observations"]] == 0
+  if (any(zero_mask, na.rm = TRUE)) {
+    zero_terms <- result$counts_df$names[zero_mask]
+    warning(paste0("No records for: ", paste(zero_terms, collapse = ", "),
+                   ". These terms were removed from the query."))
+    result$counts_df <- result$counts_df[!zero_mask, , drop = FALSE]
+  }
 
-  if (any(result$counts_df[["observations"]] == 0, na.rm = TRUE)) return(NULL)
+  if (nrow(result$counts_df) == 0) return(NULL)
 
   return(result)
 
@@ -217,11 +228,17 @@ parameter_validation <- function(df_counts, non_null_args)
 
     relevant_names <- df_counts$names[df_counts$prefix == prefix_expected]
 
-    # Logical condition to check whether the prefixes in data match any of the expected prefixes
-
-    if (!all(non_null_args[[query_param]] %in% relevant_names)) stop("")
+    # Logical condition to check whether the prefixes in data match any of the expected prefixes.
+    # Use case-insensitive comparison so that e.g. "baetis rhodani" matches "Baetis rhodani".
 
-    #stopifnot(all(non_null_args[[query_param]] %in% relevant_names))
+    failed_terms <- non_null_args[[query_param]][
+      !tolower(non_null_args[[query_param]]) %in% tolower(relevant_names)
+    ]
+    if (length(failed_terms) > 0) {
+      stop(paste0("Parameter '", query_param,
+                  "' contains terms not matching expected type '", prefix_expected,
+                  "': ", paste(failed_terms, collapse = ", ")))
+    }
   }
 
 }
-- 
2.43.0

